// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.8.5

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	dispatchRetryLogFieldNames          = builder.RawFieldNames(&DispatchRetryLog{})
	dispatchRetryLogRows                = strings.Join(dispatchRetryLogFieldNames, ",")
	dispatchRetryLogRowsExpectAutoSet   = strings.Join(stringx.Remove(dispatchRetryLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	dispatchRetryLogRowsWithPlaceHolder = strings.Join(stringx.Remove(dispatchRetryLogFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheDispatchRetryLogIdPrefix = "cache:dispatchRetryLog:id:"
)

type (
	dispatchRetryLogModel interface {
		Insert(ctx context.Context, data *DispatchRetryLog) (sql.Result, error)
		FindOne(ctx context.Context, id uint64) (*DispatchRetryLog, error)
		Update(ctx context.Context, data *DispatchRetryLog) error
	}

	defaultDispatchRetryLogModel struct {
		sqlc.CachedConn
		table string
	}

	DispatchRetryLog struct {
		Id              uint64    `db:"id"`                // 主键ID
		DeliveryNo      string    `db:"delivery_no"`       // 配送单号
		ExternalOrderNo string    `db:"external_order_no"` // 外部订单号
		PlatformCode    string    `db:"platform_code"`     // 配送平台代码
		PlatformOrderNo string    `db:"platform_order_no"` // 平台订单号
		RetryType       string    `db:"retry_type"`        // 重试类型：INQUIRY/DISPATCH/CANCEL/QUERY/ADD_FEE
		RetryCount      int64     `db:"retry_count"`       // 第几次重试
		MaxRetry        int64     `db:"max_retry"`         // 最大重试次数
		RetryReason     string    `db:"retry_reason"`      // 重试原因
		RetryStrategy   string    `db:"retry_strategy"`    // 重试策略：IMMEDIATE/FIXED/EXPONENTIAL
		RetryInterval   int64     `db:"retry_interval"`    // 重试间隔（秒）
		IsSuccess       int64     `db:"is_success"`        // 是否成功：1成功 0失败
		Duration        int64     `db:"duration"`          // 耗时（毫秒）
		RequestData     string    `db:"request_data"`      // 请求数据
		ResponseData    string    `db:"response_data"`     // 响应数据
		ErrorCode       string    `db:"error_code"`        // 错误码
		ErrorMsg        string    `db:"error_msg"`         // 错误信息
		ErrorType       string    `db:"error_type"`        // 错误类型：TIMEOUT/NETWORK/BUSINESS/PLATFORM
		NextRetryTime   time.Time `db:"next_retry_time"`   // 下次重试时间
		IsFinalRetry    int64     `db:"is_final_retry"`    // 是否最后一次重试：1是 0否
		FinalStatus     string    `db:"final_status"`      // 最终状态：SUCCESS/FAILED/ABANDONED
		ExtraData       string    `db:"extra_data"`        // 扩展数据
		CityCode        string    `db:"city_code"`         // 城市编码
		CreatedAt       time.Time `db:"created_at"`        // 创建时间
	}
)

func newDispatchRetryLogModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultDispatchRetryLogModel {
	return &defaultDispatchRetryLogModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`dispatch_retry_log`",
	}
}

func (m *defaultDispatchRetryLogModel) FindOne(ctx context.Context, id uint64) (*DispatchRetryLog, error) {
	dispatchRetryLogIdKey := fmt.Sprintf("%s%v", cacheDispatchRetryLogIdPrefix, id)
	var resp DispatchRetryLog
	err := m.QueryRowCtx(ctx, &resp, dispatchRetryLogIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", dispatchRetryLogRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultDispatchRetryLogModel) Insert(ctx context.Context, data *DispatchRetryLog) (sql.Result, error) {
	dispatchRetryLogIdKey := fmt.Sprintf("%s%v", cacheDispatchRetryLogIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, dispatchRetryLogRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.DeliveryNo, data.ExternalOrderNo, data.PlatformCode, data.PlatformOrderNo, data.RetryType, data.RetryCount, data.MaxRetry, data.RetryReason, data.RetryStrategy, data.RetryInterval, data.IsSuccess, data.Duration, data.RequestData, data.ResponseData, data.ErrorCode, data.ErrorMsg, data.ErrorType, data.NextRetryTime, data.IsFinalRetry, data.FinalStatus, data.ExtraData, data.CityCode)
	}, dispatchRetryLogIdKey)
	return ret, err
}

func (m *defaultDispatchRetryLogModel) Update(ctx context.Context, data *DispatchRetryLog) error {
	dispatchRetryLogIdKey := fmt.Sprintf("%s%v", cacheDispatchRetryLogIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, dispatchRetryLogRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.DeliveryNo, data.ExternalOrderNo, data.PlatformCode, data.PlatformOrderNo, data.RetryType, data.RetryCount, data.MaxRetry, data.RetryReason, data.RetryStrategy, data.RetryInterval, data.IsSuccess, data.Duration, data.RequestData, data.ResponseData, data.ErrorCode, data.ErrorMsg, data.ErrorType, data.NextRetryTime, data.IsFinalRetry, data.FinalStatus, data.ExtraData, data.CityCode, data.Id)
	}, dispatchRetryLogIdKey)
	return err
}

func (m *defaultDispatchRetryLogModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheDispatchRetryLogIdPrefix, primary)
}

func (m *defaultDispatchRetryLogModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", dispatchRetryLogRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultDispatchRetryLogModel) tableName() string {
	return m.table
}
